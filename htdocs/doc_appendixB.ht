Title:
css: styles.css
author: Dmitry Diky
author-email:diwil@mail.ru
links: doc_links.h

<H2>Appendix B - ABI</H2>

<H3>B.1 Register Usage</H3>

<P>If you are going to interface assembly routines with your C code, you need
to know how GCC uses the registers. This section describes how registers are
allocated and used by the compiler.
(You can override gcc settings by issuing -ffixed-regs=...)</P>

<P>r0,r2,r3 - are fixed registers and not used by the compiler in any way.
They cannot be used for register temporary arguments as well.</P>

<P>r1 - is a stack pointer. The compiler modifies it only in function
prologue/epilogue and when issues a function call with a long argument list.
Do not modify it under any circumstances!!!</P>

<P>r4 - frame pointer. This can be used by the compiler, when va_args function
call being performed. When no such call required and optimization is turned
on, this register is eliminated by stack pointer register.</P>

<P>r5 - argument pointer. This can be used by the compiler, when long arg list
call being performed. It refers to the stack position before function call.
Normally, when optimization is turned on, this register usage is eliminated
and arg list accessed via stack pointer register.</P>

<P>Use last two with care. If gcc uses them for pointer's purposes, 
these initial values after function's prologue:</P>

<P>r5 = r1 + [size of pushed regs in prologue] + 2 bytes;
r4 = r1 - [frame size];
where r1 value is r1 on function entry minus size of pushed regs in
prologue.</P>

<P>r15,r14,r13,r12 - are call cloberred (in general) registers. If you
interfacing gcc with assembler language, you do not have to save these
registers (except in interrupt service routines).</P>

<P>*** NOTE *** some library calls (such as divmodM, mulM) clobber some
registers (r8 - r11). GCC minds this fact during code generation and will
save clobbered registers on stack in calling function.</P>

<P>All other register are call used registers. If you interfacing gcc with
assembler language, you have to save them on stack and restore before exit.</P>

<P>Registers allocated in order from r12 to r15, r11 to r0 and from r15 to r0
with -mreorder flag. Please use this order if you plug in you assembler
functions.</P>

<P>char, int and pointer variables take one register.  long and float variables
take two register in little-endian order - LSB goes in lower register.
long long var takes 4 registers in little-endian order.</P>



<H3>B.2 Function call conventions</H3>

<P>Fixed Argument Lists: Function arguments are allocated left to right. They
are assigned from r15 to r12. If more parameters are passed than will fit in
the registers, the rest are passed on the stack. This should be avoided
since the code takes a performance hit when using variables residing on the
stack.</P>

<P>Variable Argument Lists: Parameters passed to functions that have a variable
argument list (printf, scanf, etc.) are all passed on the stack. char
parameters are extended to ints.</P>

<P>*** NOTE *** strarg, varargs and calls whith parameter list size over 8
bytes cannot be used with interrupt function. In this case frame pointer can
be adjusted incorrectly, which results in unpredictable code behaviour.</P>

<P>Return Values: char, int and pointer being returned in r15
long and float return in r15:r14
long long returns in r15:r14:r13:r12</P>

<P>In case the return value wider than 64 bits, it returns in memory. The first
'hidden' argument to function call will be a memory address. All other
arguments will be allocated in usual way from r14.</P>



<H3>B.3 Calls definitions.</H3>

<P>All variables names are not transformed in any way, except ones with names
r0 - r15. For them a '_' is prepended. Aliasing declaration (int A asm("M");)
will not change alias. If M being specified as a direct address (see SFRs
defenitions for example), gcc will not 'globalize' this symbol. So, you can
include these 'address' defenitions into any header file.</P>

<P>Every function call starts from function prologue. In the prologue passes
call used registers (r4-r11 and r4-r15 for interrupt functions) on stack.
Then stack pointer being adjusted by subtracting frame size from r1. Naked
functions do not issue a prologue. The 'interrupt' attribute forces to save all
function used registers.</P>

<P>In every function definition
<pre>
.L__FrameSize_[function name]=[frame size] </pre> is defined.</P>

<P>For example:</P>
<pre>
main:
.L__FrameSize_main=0x12
</pre>

<P>It can be used as an immediate variable in inline assembly: <pre>
__asm__ __volatile__("add #.L__FrameSize_main, r1"::);
</pre>
</P>

<P>Every  function call ends up with a function epilogue where, first of all, 
stack pointer adjusted by adding frame size to r1. The registers being
popped from stack.
ret insn issued for usual calls, reti for interrupts, and a sequence <pre>
bic #0xf0,0(r1) 
reti </pre>
for waked-up interrupts.</P>

<P>
main() function only adjusts stack pointer, unless -mno-stack-init specified.
main() does not save registers.
main() does not return. 
main() jumps to __stop_progExec__ at the end unless -mendup-at=...
being passed to the compiler.</P>

<A href="doc_appendixE.html">Next</a>