Title: mspgcc - Appendix D
css: styles.css
author: Dmitry Diky
author-email:diwil@mail.ru
links: doc_links.h

<H2>Appendix D - Inline assembly</H2>

<H3>D.1 Syntax:</H3>

<P>In an assembler instruction using 'asm', you can specify the operands of the
instruction using C expressions.  This means you need not guess which
registers or memory locations will contain the data you want to use.</P>

<P>You must specify an assembler instruction template much like what appears
in an assembler language, plus an operand constraint string for each
operand.</P>

<P>For example:</P>
<pre>
asm("mov %1, %0": "=r" (result): "m" (source) );
</pre>

<P>Here 'source' is the C expression for the input operand while 'result'
is that of the output operand. '=' indicates, that the operand is an output.
m and r are constraints and inicate which types of addressing mode gcc has
to use in the operand.</P>

<P>Each asm statement is devided by colons into four parts:</P>
1.  The assembler instructions, defined as a single string constant:
    <pre>"mov %1, %0"</pre>

2.  A list of output operands, separated by commas. Our example uses just one:
    <pre>"=r" (result)</pre>

3.  A comma separated list of input operands. Again our example uses one
    operand only:
    <pre>"m" (source)</pre>

4.  Clobbered registers, left empty in our example.

<P>So, the pattern is: 
    <pre>asm( (string assm statement) : [outputs]:[inputs]:[clobbers]);</pre>
</P>

<P>In our example %0 refers to result, %1 refers to source and so on.</P>

<P>Each input and output operand is described by a constraint string followed
by a C expression in parantheses.
MSP430-AVR knows the following constraint characters:
<pre>
m - memory operand
I - integer operand
r - register operand
i - immediate operand (int constants in most cases)
P - constants, generated by r2 and r3
</pre>
and some other constraints which are common for gcc. MSP430-gcc does not use
any other constraints cause of the mcu core architecture.</P>

<P>Digit in constraint indicates, that the current operand must occupy the same
location as operand 'digit' :</P>
<pre style="font-size:10pt">
    asm ("add %2,%0" : "=r" (foo) : "r" (foo), "m" (bar));
is 
    foo += bar;
and will result in assembler output as:

    mov &foo, r12
/* #APP */
    add &bar, r12
/* #NOAPP */
    mov r12, &foo	; foo is a global variable.
</pre>

<P>If you are writing a header file that should be includable in ANSI C
programs, write '__asm__' instead of 'asm'.
If there are only unused output operands, you will then also
need to specify 'volatile' for the 'asm' construct.</P>

<P>A percent '%' sign follwed by a digit forces gcc to substitute an operand
'digit'. For 4 and 8 byte operands use %A, %B, %C, %D modifiers:
<pre style="font-size:10pt">
#define LONGVAL	0x12345678l

{
    long a,b;
    ...
    asm("mov %A2, %A0 \n\t"
        "mov %B2, %B0 \n\t" 
        "mov %A2, %A1 \n\t" 
        "mov %B2, %B1 \n\t" 

            : "=r"((long)a),"=m"((long)b)
            : "i"((long)LONGVAL) );
    ...
}

this will result as ('b' declared within a block):
    ...
/* #APP */
    mov #llo(305419896), r12
    mov #lhi(305419896), r13
    mov #llo(305419896), 4(r1) ; mov #llo(305419896), &b   <- if b declared
    mov #lhi(305419896), 6(r1) ; mov #lhi(305419896), &b+2 <- as global var
/* #NOAPP*/
    mov r12, 0(r1)
    mov r13, 2(r1)
    ...
</pre></P>

<P>So,

%A[digit] acts as %[digit] for memory and register operands and wraps
integer value into #llo(), where #llo is an assembler macro, which extracts
lower 16 bits.</P>

<P>%B add 1 to register number, 2 to address constants, and substitudes #lhi()
for integer consts.</P>

<P>%C add 2 to reg, 4 to addr const and #hlo() for consts.</P>

<P>%D add 3 to reg, 6 to mem, #hhi() for consts.</P>

<P>I,J,K,L modifiers do the same, except they add 1 to address and register.
They being used only in zero_extendMN operations.</P>

<P>There is also %E modifier, which substitudes Rn from (mem:xx (reg:xx n)) as
@Rn. This is a usefull modifier for first element on stack or for pointers.
!!! Do not use it unless you know exactly what are you doing !!!
</P>

<H3>D.2 Registers, variables and labels.</H3>

<P>As long as gcc does not check (and it cannot) the assembler syntax, you're
can do anything within assembler asm() statement. However, please note, that
gcc does not use r0,r2,r3. Therefore, if you mention one of these registers
as an output parameter in asm() statement or as an alias for register
variable, gcc will substitude some another register instead. If r2,r3,r0
being used as input parameters, you'll get an error: `asm' operand requires
impossible reload.</P>

<P>Variables can be used in normal way within asm() statement (mind name
conversion for [Rr][0-15] names)</P>

<P>Gcc defines labels with the following patterns:</P>
<table border=0>
 <TR><TD><code>.Lfe%=</code> </TD>
     <TD>function end label</TD>
 </TR>
 <TR><TD><code>.L__Frame_size_%s</code> </TD>
     <TD> see above</TD>
 </TR>
 <TR><TD><code>.L%=</code> </TD>
     <TD> local label for almost all purposes :)</TD>
 </TR>
</table><br>
(%= modifier stands for a unique number for entire file)
</P>

<P>Following labels defined for some expanded operands:
<pre>
.Lsren%=
.Lsrcl%=
.Lsre%=
.Lae%=
.Lmsn%=
.Lcsn%=
.Lsend%=
.Lsst%=
.Leaq%=
.LcmpSIe%=
</pre></P>

<P>So, do not use these patterns. You can use any else label as you wish. Please 
note, that if label starts from .L it means, that the label is local and cannot
be seen from another file as well as in disassembled output with objdump.</P>

<H3>D.3 Library calls.</H3>

<P>There are some library functs used by GCC for code generation.</P>

<P>All of them use non-standard argument passing scheme. So, do not use them in
your assembly code unless absolutelly sure what's going on. Namely:</P>

<B>Multiplication:</B>
<pre>
__mul{qi,hi,si}3
__umul{qi,hi,si}3
__umulsi3hw
</pre>

<P>If destination is in HI mode (16 bit) or QI mode (8 bit), for archetectures
without hardware multiplier, the first argument being passed in r10, 
second - 12, returns in r14.
In SI mode (32 bit): first in r11:r10, second r13:r12, result in r14:r15.</P>

<P>In both cases input arguments are clobbered after function returns.</P>

<B>Division:</B>
<pre>
__divmod{qi,hi,si}4
__udivmod{qi,hi,si}4
</pre>

<P>If destination is in HI mode (16 bit) or QI mode (8 bit):
inputs are in r12, r10 (r12 / r10); 
outputs are in r12 - quotant, r14 - reminder;
r10, r11 and r13 are clobbered.</P>

<P>In SI mode (32 bit):
inputs are in r13:r12 and r11:r10;
outputs are in r13:r12 - quotant, r15:r14 - reminder;
r8,r9,r10,r11 are cloberred.</P>

<P>All floating point library calls can be used the usual way 
(when applicable - just help me to force this process :).</P>

<P><A href="doc_appendixE.html">Next</a></P>