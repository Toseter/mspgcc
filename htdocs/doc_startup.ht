Title: mspgcc - Application startup
css: styles.css
author: Dmitry Diky
author-email:diwil@mail.ru
links: doc_links.h

<H2>4. Application Start-up</H2>

<P>The standard library includes a start-up module that prepares the
environment for running applications written in C. Several versions of the
start-up script are available because each processor has different set-up
requirements. The compiler, msp430-gcc, selects the appropriate module based
upon the processor specified by command line options (see Appendix A).</P>


<P>For the MSP430 processors, the start-up module is responsible for the following
tasks:</P>

<li> Providing a default vector table.
<li> Providing default interrupt handlers.
<li> Initializing the globally-reserved registers.
<li> Initializing the watchdog.
<li> Initializing the mcucr register.
<li> Initializing the data segment.
<li> Zeroing out the .bss segment.
<li> Jumping to main(). (A jump is used, rather than a call, to save space on
  the stack. main() is not expected to return. )

<P>The start-up module contains a default interrupt vector table. The contents
of the table are filled with predefined function names which can be
overridden by the programmer. This is discussed completely in Chapter XX.
The last entry in the table, however, is the address of the reset vector.
The _reset_vector__ is defined to be a weak symbol, which means that if the
application doesn't define it, the linker will use the value from the
library (or module).</P>

<P>Look at the disassembled code (msp430-objdump -DS a.out):</P>
<pre style="font-size:10pt">
------------------------- cut ------------------------------------
a.out:     file format elf32-msp430

Disassembly of section .text:

0000fc00 <_reset_vector__>:
    fc00:	b2 40 80 5a 	mov	#23168,	&0x0120	;  #0x5a80
    fc04:	20 01 
    fc06:	3f 40 50 fc 	mov	#-944,	r15	;  #0xfc50
    fc0a:	3e 40 00 02 	mov	#512,	r14	;  #0x0200
    fc0e:	3d 40 00 02 	mov	#512,	r13	;  #0x0200
    fc12:	0d 9e       	cmp	r14,	r13	
    fc14:	06 24       	jz	$+14     	;  abs dst addr 0xfc22
    fc16:	1d 53       	inc	r13		
    fc18:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	
    fc1c:	1e 53       	inc	r14		
    fc1e:	0f 9d       	cmp	r13,	r15	
    fc20:	fb 2b       	jnc	$-8      	;  abs dst addr 0xfc18
    fc22:	3f 40 00 02 	mov	#512,	r15	;  #0x0200
    fc26:	3d 40 00 02 	mov	#512,	r13	;  #0x0200
    fc2a:	0d 9f       	cmp	r15,	r13	
    fc2c:	06 24       	jz	$+14     	;  abs dst addr 0xfc3a
    fc2e:	1d 53       	inc	r13		
    fc30:	cf 43 00 00 	mov.b	#0,	0(r15)	;  subst r3 with As==00
    fc34:	1f 53       	inc	r15		
    fc36:	0f 9d       	cmp	r13,	r15	
    fc38:	fb 2b       	jnc	$-8      	;  abs dst addr 0xfc30
    fc3a:	30 40 44 fc 	br	#0xfc44	

0000fc3e <_unexpected_1_>:
    fc3e:	30 40 42 fc 	br	#0xfc42	

0000fc42 <_unexpected_>:
    fc42:	00 13       	reti			

0000fc44 <main>:
    fc44:	31 40 80 02 	mov	#640,	SP	;  #0x0280
    fc48:	30 40 4c fc 	br	#0xfc4c	

0000fc4c <__stop_progExec__>:
    fc4c:	02 43       	clr	SR		
    fc4e:	fe 3f       	jmp	$-2      	;  abs dst addr 0xfc4c
Disassembly of section .data:
Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	3e fc       	interrupt service routine at 0xfc3e
    ffe2:	3e fc       	interrupt service routine at 0xfc3e
    ffe4:	3e fc       	interrupt service routine at 0xfc3e
    ffe6:	3e fc       	interrupt service routine at 0xfc3e
    ffe8:	3e fc       	interrupt service routine at 0xfc3e
    ffea:	3e fc       	interrupt service routine at 0xfc3e
    ffec:	3e fc       	interrupt service routine at 0xfc3e
    ffee:	3e fc       	interrupt service routine at 0xfc3e
    fff0:	3e fc       	interrupt service routine at 0xfc3e
    fff2:	3e fc       	interrupt service routine at 0xfc3e
    fff4:	3e fc       	interrupt service routine at 0xfc3e
    fff6:	3e fc       	interrupt service routine at 0xfc3e
    fff8:	3e fc       	interrupt service routine at 0xfc3e
    fffa:	3e fc       	interrupt service routine at 0xfc3e
    fffc:	3e fc       	interrupt service routine at 0xfc3e
    fffe:	00 fc       	interrupt service routine at 0xfc00

------------------------- cut ------------------------------------
</pre>

<P>Ok. Lets start from the end. Every msp430 device has interrupt vectors table
located at 0xffe0. So, here we can see, that on execution begins, the PC
loaded with the address 0xfc00. _reset_vector__ located at this address.
Here, first of all, watchdog timer being initialized.</P>

<P>Then the program copies initialized global variables to RAM (0xfc0a - 0xfc20). 
After it uninitialized globals being cleared (0xfc22 - 0xfc3a).
At the end of this procedure we jump to 'main' which located at 0xfc44.</P>

<P>In main one can see, that we copy value 0x0280 to r1. It initializes a stack
pointer, taking into account the space required for local variables.</P>

<P>Then, as long as main does nothing, it jumps to __stop_progExec__. At this
point SR zeroed. Next assembler instruction is jump to __stop_progExec__.
This provides end-of-program-execution.</P>

<P>In this module, the application use
_etext - end of .text section. The point where initial values of global
variables being coded,
__data_start - start of ram,
_edata - end of data RAM (_edata-__data_start is a size of .data segment),
__bss_start - a point where uninitialized variables resides in RAM,
__bss_end - end of this segment ,
__stack - is ... stack...
</P>

<P>All of these variables can be overridden with -Wl,--defsym=[symname]=(value)
For example, to define stack to 0x111, use '-Wl,--defsym=__stack=0x111'.</P>

<P>In most cases it is not necessary to redefine these values. They can be
obtained from the user application as:</P>
<pre>
...
extern int __stack;
int m;
(int *)m = &__stack;
/* now m filled with __stack value */
...
</pre>

<P>Please note, that these values do not change once been initialized.</P>

<P>The startup code adds a litter overhead to the application. The size of the
startup code is 80 bytes without interrupt vector table. If you do not like
this approach, you can define your own startup code.</P>

<H3>4.1 Redefine startup procedure</H3>

<P>By defining _reset_vector__ in the user application, the linker will not
link standard startup code. For example:</P>

<pre>
#include <io.h>

NAKED(_reset_vector__)
{
	/* place your startup code here */

	/* Make shure, the branch to main (or to your start
	   routine) is the last line in the function */
	__asm__ __volatile__("br #main"::);
}
</pre>

<P>Then we'll get </P>
<pre style="font-size:10pt">
---
a.out:     file format elf32-msp430

Disassembly of section .text:

0000fc00 <__zero_vector>:
    fc00:       30 40 04 fc     br      #0xfc04

0000fc04 <_unexpected_>:
    fc04:       00 13           reti

0000fc06 <_reset_vector__>:
    fc06:       00 3c           jmp     $+2             ;  abs dst addr 0xfc08

0000fc08 <main>:
    fc08:       31 40 80 02     mov     #640,   SP      ;  #0x0280
    fc0c:       30 40 10 fc     br      #0xfc10

0000fc10 <__stop_progExec__>:
    fc10:       02 43           clr     SR
    fc12:       fe 3f           jmp     $-2             ;  abs dst addr 0xfc10
Disassembly of section .data:
Disassembly of section .vectors:
[skip]
---
</pre>

<P>Please note, if you declare your own startup, you have to take care about
global variables initial values.</P>

<P>An another way to define reset, is to use _RESET() macro:</P>
<pre>
_RESET()
{
	/* place your startup code here */
	__asm__ __volatile__("br #main"::);
}
</pre>

<H3>4.2 Redefine end up procedure</H3>

<P>From the example above you can see, that main jumps to __stop_progExec__,
which can be redefined the same way in the user code. However, it is possible
to save some space, specifying return point for main:</P>
<pre>
	msp430-gcc -mendup-at=main ...
</pre>

<P>Then, you'll get:</P>
<pre style="font-size:10pt">
...
0000fc08 <main>:
    fc08:       31 40 80 02     mov     #640,   SP      ;  #0x0280
    fc0c:       30 40 10 fc     br      #0xfc08
...
</pre>

<P>And __stop_progExec__ will not be linked.</P>

<H3>4.3 Initializing stack.</H3>

<P>Stack initialization performed in main's prologue. This is suitable for
most cases. But if user redefines startup and needs some space allocated on
stack, the stack has to be initialized. For example:</P>
<pre>
NAKED(_reset_vector__)
{
	__asm__ __volatile__("mov #__data_start, r1"::);
	/* your code */
	__asm__ __volatile__("br #main"::);
}
</pre>

<P>*** NOTE *** DO NOT USE IAR's registers defenition PC, SP and SR cause GNU
assembler does not handle it. Instead use r0, r1 and r2.</P>


<P>Then stack finally will be initialized in main(). Normally, the stack bottom
initial address is a top of ram. If you want to reserve some RAM space,
which is not accessible for the compiler, you may specify -mno-stack-init
flag and then define startup as follows:</P>
<pre>
#define STACKINITIALVALUE	0x0111	// for example

NAKED(_reset_vector__)
{
	char a[100];	// will be allocated on stack
	__asm__ __volatile__("mov #__data_start, r1"::);
	
	/* your startup code here */
	
	/* init stack */
	__asm__ __volatile__("mov %0, r1"
				:
				: "i" (STACKINITIALVALUE)
				);
	/* jump to main */
	__asm__ __volatile__("br #main"::);
}
</pre>

<P>If you do not nake the function declaration, please note, that on function
exit, the frame pointer value will be added to the r1, So, stack init should
be as follows:</P>

<P>*** NOTE *** Frame pointer register r4 and arguments pointer register r5
values are compilated in some misterious way. So, use the with care (see
Appendix B)</P>
<pre>
...
__asm__ __volatile__("mov %0, r1" :: "i" (STACKINITIALVLUE) );
__asm__ __volatile__("sub #.L__FrameSize__reset_vector__, r1"::);
...
</pre>

<P>The variable '.L__FrameSize_[function name]' defined by the compiler and has a
value of the stack space required.</P>


<P>For example:</P>
<pre>
----
#define STACKINITIALVLUE 0x111

void set(char *a) {}	// dummy
void reset(char *a) {}  // dummy

void _reset_vector__()
{
        __asm__ __volatile__("mov       #__data_start ,r1"::);
        {
                char a[100];
                set(a);
                reset(a);
        }
        __asm__ __volatile__("mov %0, r1"::"i" (STACKINITIALVLUE));
        __asm__ __volatile__("sub #.L__FrameSize__reset_vector__, r1"::);
	__asm__ __volatile__("br #main"::);
}

int main(){ }
----
</pre>

<P>Will result as (msp430-gcc -O m.c -mendup-at=main -mno-stack-init):</P>
<pre style="font-size:10pt">
---
a.out:     file format elf32-msp430

Disassembly of section .text:

0000fc00 <__zero_vector>:
    fc00:       30 40 04 fc     br      #0xfc04

0000fc04 <_unexpected_>:
    fc04:       00 13           reti

0000fc06 <set>:
    fc06:       30 41           ret

0000fc08 <reset>:
    fc08:       30 41           ret

0000fc0a <_reset_vector__>:
    fc0a:       31 80 64 00     sub     #100,   SP      ;  #0x0064
    fc0e:       31 40 00 02     mov     #512,   SP      ;  #0x0200
    fc12:       0f 41           mov     r1,     r15
    fc14:       b0 12 06 fc     call    #-1018          ;  #0xfc06
    fc18:       0f 41           mov     r1,     r15
    fc1a:       b0 12 08 fc     call    #-1016          ;  #0xfc08
    fc1e:       31 40 11 01     mov     #273,   SP      ;  #0x0111
    fc22:       30 40 30 fc     br      #0xfc30
    fc26:       31 80 64 00     sub     #100,   SP      ;  #0x0064
    fc2a:       31 50 64 00     add     #100,   SP      ;  #0x0064
    fc2e:       30 41           ret

0000fc30 <main>:
    fc30:       30 40 30 fc     br      #0xfc30
....
---
</pre>

<P>I personally do not like this approach. Later, I'll make something like
attribute for main() with which the stack pointer can be adjusted.
... just made it. see Chapter 5.2</P>


<P>There are two more functions __zero_vector and _unexpected_ which are not
described here. They are part of interrupt processing scheme and we'll talk
about it in the interrupt API chapter. </P>

<A href="doc_memapi.html">Next</a>